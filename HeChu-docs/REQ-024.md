# REQ-024: Web 拖拽功能修复 - 支持图片拖入

## 状态
- [ ] 待开发
- [ ] 开发中
- [x] 已完成

## 创建信息
- 创建时间: 2026-02-16
- 最后更新: 2026-02-16
- 优先级: 高

## 需求描述

修复 Blazor WebAssembly 前端的拖拽功能，使用户能够通过拖拽图片文件到棋盘区域来加载谜题。

### 问题现象

用户将图片文件拖入棋盘区域时，显示提示"请使用顶部工具栏的'打开截图'按钮选择文件"，拖拽功能完全不可用。

### 根本原因

Blazor 的 `@ondrop` 事件处理器无法直接访问浏览器的 `DataTransfer.files` API，导致：

1. `OnDrop()` 方法只是一个空的占位函数，只显示提示信息
2. 没有实际的文件读取和处理逻辑
3. 缺少 JavaScript 互操作来访问拖拽文件

```csharp
// 修复前的代码
private void OnDragOver() { }

private void OnDrop()
{
    _statusMessage = "请使用顶部工具栏的\"打开截图\"按钮选择文件";
}
```

## 技术实现

### 1. JavaScript 互操作 (interop.js)

添加 `setupDropZone` 函数，使用原生 DOM API 处理拖拽：

```javascript
setupDropZone: function (element, dotNetHelper) {
    if (!element) return;
    
    element.addEventListener('drop', async function (e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!e.dataTransfer || !e.dataTransfer.files || e.dataTransfer.files.length === 0) {
            return;
        }
        
        var file = e.dataTransfer.files[0];
        if (!file.type.startsWith('image/')) {
            await dotNetHelper.invokeMethodAsync('OnDropError', '请拖入图片文件（PNG/JPG）');
            return;
        }
        
        try {
            var buffer = await file.arrayBuffer();
            var bytes = new Uint8Array(buffer);
            await dotNetHelper.invokeMethodAsync('OnDropFile', bytes, file.name);
        } catch (error) {
            console.error('Drop file error:', error);
            await dotNetHelper.invokeMethodAsync('OnDropError', '读取文件失败');
        }
    });
    
    element.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();
    });
}
```

#### 关键点

1. **文件验证**：检查 `DataTransfer.files` 是否存在和是否为图片类型
2. **异步读取**：使用 `file.arrayBuffer()` 读取文件内容为字节数组
3. **回调 Blazor**：通过 `dotNetHelper.invokeMethodAsync` 调用 C# 方法
4. **错误处理**：捕获异常并回调错误处理方法

### 2. Blazor 组件更新 (Index.razor)

#### 移除 Blazor 拖拽事件处理器

```cshtml
<!-- 修复前 -->
<div class="board-container"
     @ondragover="OnDragOver"
     @ondragover:preventDefault
     @ondrop="OnDrop"
     @ondrop:preventDefault>

<!-- 修复后 -->
<div class="board-container" @ref="_boardContainer">
```

#### 添加组件字段

```csharp
private ElementReference _boardContainer;
private DotNetObjectReference<Index>? _dotNetHelper;
```

#### 实现 IDisposable

```csharp
@implements IDisposable

public void Dispose()
{
    _dotNetHelper?.Dispose();
}
```

#### 初始化拖拽监听

```csharp
protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        _dotNetHelper = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("blazorInterop.setupDropZone", 
            _boardContainer, _dotNetHelper);
    }
}
```

#### JavaScript 可调用方法

```csharp
[JSInvokable]
public async Task OnDropFile(byte[] bytes, string fileName)
{
    _isLoading = true;
    _statusMessage = "正在上传并识别...";
    StateHasChanged();

    try
    {
        using var stream = new MemoryStream(bytes);
        var result = await Api.DetectAndSolveAsync(stream, fileName);

        if (result.IsSuccess)
        {
            _puzzle = result.Puzzle;
            _solution = result.Solution;
            _statusMessage = _solution is { IsSolved: true } 
                ? "识别并求解成功" 
                : (_solution?.Message ?? "无解");
            Toast.ShowSuccess("图片识别成功");
        }
        else
        {
            _puzzle = null;
            _solution = null;
            _statusMessage = $"识别失败: {result.Error}";
            Toast.ShowError(result.Error ?? "识别失败");
        }
    }
    catch (HttpRequestException)
    {
        _statusMessage = "无法连接到后端服务，请检查 API 地址配置";
        Toast.ShowError("无法连接到后端服务");
    }
    catch (Exception ex)
    {
        _statusMessage = $"拖拽失败: {ex.Message}";
        Toast.ShowError(ex.Message);
    }
    finally
    {
        _isLoading = false;
        StateHasChanged();
    }
}

[JSInvokable]
public void OnDropError(string message)
{
    _statusMessage = message;
    Toast.ShowWarning(message);
    StateHasChanged();
}
```

### 3. 架构模式

采用 **JavaScript 互操作 + Blazor 回调** 模式：

```
用户拖拽文件
    ↓
DOM Drop Event (JavaScript)
    ↓
读取文件为 byte[]
    ↓
dotNetHelper.invokeMethodAsync('OnDropFile', bytes, name)
    ↓
Blazor C# 方法处理
    ↓
调用 API 识别
    ↓
更新 UI 显示结果
```

## 实现细节

### 为什么不能用纯 Blazor？

Blazor 的拖拽事件 (`@ondrop`) 只能提供事件对象的部分信息，不包括：
- `DataTransfer.files` 集合
- `DataTransfer.items` 集合
- 文件的实际内容

这些都是浏览器安全沙箱限制的一部分。

### 资源管理

使用 `DotNetObjectReference` 在 JavaScript 和 C# 之间传递对象引用：

1. **创建引用**：`DotNetObjectReference.Create(this)`
2. **传递给 JS**：作为参数传递给 `setupDropZone`
3. **JS 回调**：通过 `invokeMethodAsync` 调用 C# 方法
4. **释放资源**：在 `Dispose` 中调用 `_dotNetHelper?.Dispose()`

### 文件类型验证

在 JavaScript 层面进行早期验证，避免传输非图片文件：

```javascript
if (!file.type.startsWith('image/')) {
    await dotNetHelper.invokeMethodAsync('OnDropError', '请拖入图片文件（PNG/JPG）');
    return;
}
```

## 验证结果

### 编译状态
- ✅ 0 错误
- ✅ 0 警告
- ✅ 编译成功

### 功能测试

#### 成功场景
- ✅ 从文件管理器拖入 PNG 图片 → 识别成功
- ✅ 从文件管理器拖入 JPG 图片 → 识别成功
- ✅ 拖入后显示加载状态 → 正常
- ✅ 识别完成后更新棋盘 → 正常
- ✅ Toast 提示显示 → 正常

#### 错误处理
- ✅ 拖入非图片文件 → 显示警告"请拖入图片文件"
- ✅ 文件读取失败 → 显示错误"读取文件失败"
- ✅ API 连接失败 → 显示错误"无法连接到后端服务"
- ✅ 识别失败 → 显示具体错误信息

#### 边界情况
- ✅ 拖入多个文件 → 只处理第一个
- ✅ 重复拖入 → 每次都重新识别
- ✅ 已有谜题时拖入 → 替换为新谜题

## 相关文件

### 修改文件
- `src/EndfieldPuzzleSolver.Web/wwwroot/js/interop.js` - 添加 setupDropZone 函数
- `src/EndfieldPuzzleSolver.Web/Pages/Index.razor` - 添加拖拽处理逻辑

### 新增依赖
- 无（使用现有的 IJSRuntime）

## 用户体验改进

### 修复前
❌ 拖入图片无反应，只显示提示信息  
❌ 必须使用"打开截图"按钮  
❌ 用户体验不连贯

### 修复后
✅ 拖入图片立即识别  
✅ 多种输入方式（拖拽/打开/粘贴）  
✅ 流畅的用户体验

## 技术参考

### Blazor 文件处理
- 官方文档：[File uploads in Blazor](https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads)
- JavaScript 互操作：[Call JavaScript from .NET](https://learn.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/call-javascript-from-dotnet)

### 浏览器 API
- [DataTransfer API](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)
- [File API](https://developer.mozilla.org/en-US/docs/Web/API/File)
- [FileReader API](https://developer.mozilla.org/en-US/docs/Web/API/FileReader)
