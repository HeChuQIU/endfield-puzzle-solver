# REQ-022: 增强图片输入体验 - 拖入提示与剪贴板粘贴功能

## 状态
- [ ] 待开发
- [ ] 开发中
- [x] 已完成

## 创建信息
- 创建时间: 2026-02-14
- 最后更新: 2026-02-14
- 优先级: 中

## 需求描述

优化图片输入的用户体验，在两个应用（WinUI3 和 Avalonia）中增加两个新功能：

1. **未加载谜题时显示拖入提示**：在谜题主体区域添加视觉提示，引导用户拖入截图或使用粘贴功能
2. **剪贴板粘贴功能**：添加"粘贴截图"按钮并支持 Ctrl+V 快捷键，方便用户在截图后直接粘贴

### 初始设计问题

最初设计将粘贴按钮放在 BoardPlaceholder 中，导致只有应用刚启动（未加载谜题）时才能粘贴。这不合理，因为用户可能需要在已加载谜题后粘贴新的截图。

### 最终设计

**1. 工具栏按钮**
- 将"粘贴截图"按钮移到顶部工具栏，与"打开截图"按钮并列
- 按钮始终可见可用，无论是否已加载谜题

**2. 谜题主体区域提示（未加载时显示）**
- 图标：文件夹图标
- 主提示："拖入截图以加载谜题"
- 副提示："或使用顶部工具栏粘贴截图"

**3. 剪贴板支持**
- 支持截图位图数据（最常用场景）
- 支持复制的图片文件
- 支持 Ctrl+V 快捷键

## 技术实现

### 共享 ViewModel (MainViewModel.cs)

添加剪贴板回调和命令：

```csharp
/// <summary>
/// 由 View 层设置，用于从剪贴板获取图片并保存为临时文件，返回路径。
/// 返回 null 表示剪贴板中没有图片。
/// </summary>
public Func<Task<string?>>? GetClipboardImagePathAsync { get; set; }

[RelayCommand]
public async Task PasteFromClipboardAsync()
{
    if (GetClipboardImagePathAsync == null)
    {
        StatusMessage = "当前平台不支持剪贴板粘贴";
        return;
    }

    IsLoading = true;
    StatusMessage = "正在从剪贴板读取图片...";
    try
    {
        var path = await GetClipboardImagePathAsync();
        if (path == null)
        {
            StatusMessage = "剪贴板中没有图片";
            return;
        }

        await LoadFromScreenshotAsync(path);
    }
    catch (Exception ex)
    {
        StatusMessage = $"粘贴失败: {ex.Message}";
    }
    finally
    {
        IsLoading = false;
    }
}
```

### WinUI3 实现 (MainWindow.xaml + MainWindow.xaml.cs)

**XAML: 工具栏添加粘贴按钮**

```xml
<CommandBar Grid.Row="0" DefaultLabelPosition="Right">
    <AppBarButton x:Name="OpenScreenshotBtn" Icon="OpenFile" Label="打开截图" />
    <AppBarButton x:Name="PasteClipboardBtn" Label="粘贴截图">
        <AppBarButton.Icon>
            <FontIcon Glyph="&#xE77F;" />
        </AppBarButton.Icon>
    </AppBarButton>
</CommandBar>
```

**XAML: 棋盘区域提示**

```xml
<Grid>
    <Canvas x:Name="BoardCanvas" />
    <StackPanel x:Name="BoardPlaceholder" HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="12">
        <FontIcon Glyph="&#xE8B9;" FontSize="48" HorizontalAlignment="Center" Opacity="0.4" />
        <TextBlock Text="拖入截图以加载谜题" FontSize="16" HorizontalAlignment="Center" Opacity="0.6" TextWrapping="Wrap" />
        <TextBlock Text="或使用顶部工具栏粘贴截图" FontSize="14" HorizontalAlignment="Center" Opacity="0.5" TextWrapping="Wrap" />
    </StackPanel>
</Grid>
```

**C#: 剪贴板实现 (关键修复)**

初始实现直接复制流导致识别错误，修复方法是使用 Windows Imaging Component 正确编码：

```csharp
private async Task<string?> GetClipboardImagePathAsync()
{
    var content = Windows.ApplicationModel.DataTransfer.Clipboard.GetContent();

    if (content.Contains(Windows.ApplicationModel.DataTransfer.StandardDataFormats.Bitmap))
    {
        try
        {
            var reference = await content.GetBitmapAsync();
            using var stream = await reference.OpenReadAsync();
            
            // 使用 BitmapDecoder/Encoder 正确编码为 PNG
            var decoder = await Windows.Graphics.Imaging.BitmapDecoder.CreateAsync(stream);
            var softwareBitmap = await decoder.GetSoftwareBitmapAsync();
            
            var tempPath = System.IO.Path.Combine(System.IO.Path.GetTempPath(), 
                $"endfield_clipboard_{DateTime.Now:yyyyMMddHHmmss}.png");
            using var fileStream = File.Create(tempPath);
            var randomAccessStream = fileStream.AsRandomAccessStream();
            
            var encoder = await Windows.Graphics.Imaging.BitmapEncoder.CreateAsync(
                Windows.Graphics.Imaging.BitmapEncoder.PngEncoderId, 
                randomAccessStream);
                
            encoder.SetSoftwareBitmap(softwareBitmap);
            await encoder.FlushAsync();
            
            return tempPath;
        }
        catch
        {
            // 位图解码失败，继续尝试其他方式
        }
    }

    // 尝试复制的图片文件
    if (content.Contains(Windows.ApplicationModel.DataTransfer.StandardDataFormats.StorageItems))
    {
        var items = await content.GetStorageItemsAsync();
        foreach (var item in items)
        {
            if (item is Windows.Storage.StorageFile file &&
                SupportedImageExtensions.Contains(file.FileType.ToLowerInvariant()))
            {
                return file.Path;
            }
        }
    }

    return null;
}
```

**C#: 快捷键支持**

```csharp
// 支持 Ctrl+V 快捷键粘贴
RootGrid.KeyboardAccelerators.Add(new Microsoft.UI.Xaml.Input.KeyboardAccelerator
{
    Key = Windows.System.VirtualKey.V,
    Modifiers = Windows.System.VirtualKeyModifiers.Control
});
RootGrid.KeyboardAccelerators[^1].Invoked += async (_, _) => await ViewModel.PasteFromClipboardAsync();
```

**C#: Placeholder 可见性控制**

```csharp
private void UpdatePuzzleInfo()
{
    var vm = ViewModel;
    if (vm.PuzzleData == null)
    {
        // ...
        BoardPlaceholder.Visibility = Visibility.Visible;
        return;
    }

    // ...
    BoardPlaceholder.Visibility = Visibility.Collapsed;
    // ...
}
```

### Avalonia 实现 (MainWindow.axaml + MainWindow.axaml.cs)

**AXAML: 工具栏添加粘贴按钮**

```xml
<Border Grid.Row="0" Background="{DynamicResource SystemControlBackgroundChromeMediumBrush}" Padding="8">
  <StackPanel Orientation="Horizontal" Spacing="8" HorizontalAlignment="Right">
    <Button Command="{Binding OpenScreenshotCommand}" HorizontalContentAlignment="Center">
      <StackPanel Orientation="Horizontal" Spacing="8">
        <PathIcon Data="..." Width="16" Height="16" />
        <TextBlock Text="打开截图" />
      </StackPanel>
    </Button>
    <Button Command="{Binding PasteFromClipboardCommand}" HorizontalContentAlignment="Center">
      <StackPanel Orientation="Horizontal" Spacing="8">
        <PathIcon Data="..." Width="16" Height="16" />
        <TextBlock Text="粘贴截图" />
      </StackPanel>
    </Button>
  </StackPanel>
</Border>
```

**AXAML: 棋盘区域提示（使用绑定控制可见性）**

```xml
<StackPanel x:Name="BoardPlaceholder" HorizontalAlignment="Center" VerticalAlignment="Center" Spacing="12"
            IsVisible="{Binding !HasPuzzle}">
  <PathIcon Data="..." Width="48" Height="48" HorizontalAlignment="Center" Opacity="0.4" />
  <TextBlock Text="拖入截图以加载谜题" FontSize="16" HorizontalAlignment="Center" Opacity="0.6" TextWrapping="Wrap" />
  <TextBlock Text="或使用顶部工具栏粘贴截图" FontSize="14" HorizontalAlignment="Center" Opacity="0.5" TextWrapping="Wrap" />
</StackPanel>
```

**C#: 剪贴板实现**

```csharp
private async Task<string?> GetClipboardImagePathAsync()
{
    var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
    if (clipboard == null) return null;

    try
    {
        var formats = await clipboard.GetFormatsAsync();

        // 尝试获取剪贴板中的图片数据（截图）
        foreach (var format in new[] { "PNG", "image/png", "image/bmp", "image/jpeg" })
        {
            if (!formats.Contains(format)) continue;
            var data = await clipboard.GetDataAsync(format);
            if (data is byte[] bytes && bytes.Length > 0)
            {
                var ext = format.Contains("png") || format == "PNG" ? ".png" : ".bmp";
                var tempPath = System.IO.Path.Combine(System.IO.Path.GetTempPath(), 
                    $"endfield_clipboard_{DateTime.Now:yyyyMMddHHmmss}{ext}");
                await File.WriteAllBytesAsync(tempPath, bytes);
                return tempPath;
            }
            if (data is Stream stream && stream.Length > 0)
            {
                var ext = format.Contains("png") || format == "PNG" ? ".png" : ".bmp";
                var tempPath = System.IO.Path.Combine(System.IO.Path.GetTempPath(), 
                    $"endfield_clipboard_{DateTime.Now:yyyyMMddHHmmss}{ext}");
                await using var fs = File.Create(tempPath);
                stream.Position = 0;
                await stream.CopyToAsync(fs);
                return tempPath;
            }
        }

        // 尝试获取剪贴板中复制的图片文件
        if (formats.Contains(DataFormats.Files))
        {
            var data = await clipboard.GetDataAsync(DataFormats.Files);
            if (data is IEnumerable<IStorageItem> files)
            {
                foreach (var f in files)
                {
                    if (f is IStorageFile storageFile)
                    {
                        var path = storageFile.Path.LocalPath;
                        var ext = System.IO.Path.GetExtension(path).ToLowerInvariant();
                        if (SupportedImageExtensions.Contains(ext))
                            return path;
                    }
                }
            }
        }
    }
    catch
    {
        // 剪贴板访问可能失败
    }

    return null;
}
```

**C#: 快捷键支持**

```csharp
// 支持 Ctrl+V 快捷键粘贴
KeyDown += async (_, e) =>
{
    if (e.Key == global::Avalonia.Input.Key.V &&
        e.KeyModifiers.HasFlag(global::Avalonia.Input.KeyModifiers.Control))
    {
        await ViewModel.PasteFromClipboardAsync();
        e.Handled = true;
    }
};
```

## 边界情况处理

1. **剪贴板为空**：ViewModel 显示提示信息"剪贴板中没有图片"
2. **剪贴板格式不支持**：GetClipboardImagePathAsync 返回 null，ViewModel 显示提示
3. **平台不支持（回调未注入）**：ViewModel 显示"当前平台不支持剪贴板粘贴"
4. **图片保存失败**：异常被捕获，ViewModel 显示"粘贴失败: {错误消息}"
5. **WinUI3 位图编码失败**：捕获异常后继续尝试获取文件形式的图片

## Bug 修复

### WinUI3 粘贴识别错误

**问题**：WinUI3 应用使用粘贴功能时，识别结果错误；但拖入文件方式正确；Avalonia 应用无此问题

**原因**：WinUI3 的 `GetBitmapAsync()` 返回的流格式可能不是标准 PNG，原代码直接将其保存为 `.png` 扩展名，导致 OpenCV 无法正确读取

**修复**：使用 `BitmapDecoder` 解码位图，然后用 `BitmapEncoder.PngEncoderId` 重新编码为标准 PNG 格式

### Path 命名冲突

**问题**：编译错误 `CS0104: "Path"是"Microsoft.UI.Xaml.Shapes.Path"和"System.IO.Path"之间的不明确的引用`

**修复**：使用完全限定名 `System.IO.Path`

## 验收标准

- [x] WinUI3 应用：工具栏显示"粘贴截图"按钮
- [x] Avalonia 应用：工具栏显示"粘贴截图"按钮
- [x] 未加载谜题时，棋盘区域显示拖入提示和粘贴说明
- [x] 已加载谜题时，隐藏提示，粘贴按钮仍可用
- [x] 点击粘贴按钮后，能正确识别剪贴板中的截图
- [x] 使用 Ctrl+V 快捷键能触发粘贴功能
- [x] WinUI3 粘贴功能识别结果正确（与拖入文件一致）
- [x] Avalonia 粘贴功能识别结果正确
- [x] 剪贴板为空时显示友好提示
- [x] 编译通过，0 错误 0 警告

## 影响范围

### 修改的文件

- `src/EndfieldPuzzleSolver.Core/ViewModels/MainViewModel.cs`: 添加剪贴板回调和粘贴命令
- `src/EndfieldPuzzleSolver/MainWindow.xaml`: 添加工具栏粘贴按钮和棋盘提示
- `src/EndfieldPuzzleSolver/MainWindow.xaml.cs`: 实现剪贴板处理、快捷键、Placeholder 控制
- `src/EndfieldPuzzleSolver.Avalonia/Views/MainWindow.axaml`: 添加工具栏粘贴按钮和棋盘提示
- `src/EndfieldPuzzleSolver.Avalonia/Views/MainWindow.axaml.cs`: 实现剪贴板处理、快捷键、Placeholder 控制

### 未修改的文件

- 识别和求解逻辑无变更
- F# 求解器无变更

## 技术要点

1. **平台抽象**：剪贴板访问是平台相关的，通过回调注入到 ViewModel 实现跨平台
2. **图像格式处理**：WinUI3 需要使用 BitmapDecoder/Encoder 正确编码位图
3. **临时文件管理**：剪贴板数据保存到临时文件，使用时间戳避免冲突
4. **UI 可见性控制**：WinUI3 使用代码切换 Visibility，Avalonia 使用数据绑定 `{Binding !HasPuzzle}`
5. **错误处理**：各层次都有异常处理，确保用户看到友好提示而不是崩溃

## 用户体验提升

- **发现性更好**：未加载谜题时，明确提示用户拖入或粘贴
- **操作更快速**：截图后 Ctrl+V 直接粘贴，无需保存文件
- **始终可用**：粘贴功能不受当前状态限制，随时可替换谜题
- **多种输入方式**：按钮点击 / 快捷键 / 拖拽，满足不同用户习惯
