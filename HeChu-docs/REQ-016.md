# REQ-016: 使用 OpenCvSharp API 和 Linq 全面优化图像识别性能

## 状态

- [ ] 待开发
- [ ] 开发中
- [x] 已完成

## 创建信息

- 创建时间: 2026-02-12
- 最后更新: 2026-02-12
- 优先级: 高

## 需求描述

在 REQ-015 的分析基础上，实际实施性能优化方案。核心原则是：

1. **优先使用 OpenCvSharp API**：尽可能使用 OpenCV 内置函数和矩阵操作，而非手动循环
2. **使用 Linq 替代手动列表操作**：提高代码可读性和利用 .NET 的查询优化

目标：将 C# WinUI3 应用的识别性能提升到接近 Python 原型的水平。

## 边界条件

1. **兼容性要求**：必须确保优化后的识别结果与原 Python 实现完全一致（输出相同的 PuzzleData 结构）
2. **正确性验证**：优化后需要对比 Python 输出，确保算法结果一致
3. **性能验证**：优化后需要进行性能基准测试，对比优化前后的执行时间
4. **错误处理**：保持原有的错误处理逻辑，确保异常情况下能正常失败
5. **API 使用限制**：OpenCvSharp 某些 API 返回 void 或格式与标准 OpenCV 不同，需要仔细处理
6. **内存管理**：使用 `using` 语句正确管理 Mat 对象的生命周期，避免内存泄漏

## 技术路线

### 阶段 1：核心性能瓶颈优化

#### 1.1 SimilarityMapForColor 函数（最关键）

**位置**：PuzzleDetector.cs 605-631 行
**当前问题**：双重循环逐像素计算色相相似度
**目标**：使用 OpenCvSharp 矩阵操作替代

**实施步骤**：

1. 使用 `Cv2.Split(hsv)` 或 `Cv2.ExtractChannel` 分离 HSV 通道
2. 使用 `ConvertTo(MatType.CV_32F)` 将通道转换为 float 类型
3. 使用矩阵运算替代逐像素计算：
  - 色相距离：使用 `Cv2.AbsDiff` 计算 `|h - ch|`，然后使用 `Cv2.Min(d, 180-ch)`
  - 色相相似度：使用矩阵减法、除法（`Cv2.MultiplyScalar`）和 `Cv2.Max`
  - 饱和度/亮度检查：使用 `Cv2.Compare` 生成掩码
  - 组合结果：使用 `Cv2.BitwiseAnd` 和 `Cv2.Multiply`

**注意事项**：

- `ConvertTo` 返回 void，需要先创建目标 Mat
- 标量除法使用 `Cv2.MultiplyScalar(1.0 / hueWidth)` 而非 `DivideScalar`
- 使用 `using` 语句正确管理临时 Mat 对象

#### 1.2 MatchTemplate 函数

**位置**：PuzzleDetector.cs 254-273 行
**当前问题**：双重循环遍历结果矩阵查找阈值点
**目标**：使用 `FindNonZero` 一次性获取所有匹配点

**实施步骤**：

1. 使用 `Cv2.Threshold(res, mask, thresh, 255, ThresholdTypes.Binary)` 创建二值掩码
2. 使用 `mask.FindNonZero()` 获取所有非零点
3. 遍历返回的 Mat（2列矩阵：[x, y]）并收集结果

**注意事项**：

- `FindNonZero` 返回的是 2 列的 Mat，每行代表一个点的 [x, y] 坐标
- 需要从 Mat 中逐行读取坐标

#### 1.3 ClassifyCell 函数

**位置**：PuzzleDetector.cs 361-447 行
**当前问题**：锁定格的像素统计（377-398 行）和 fallback 中的方差计算（426-438 行）
**目标**：使用 OpenCvSharp 掩码操作和统计函数

**实施步骤**：

1. 锁定格检测：
  - 使用 `Cv2.Compare` 创建 sat > minSat && val > minVal 的掩码
  - 使用 `Cv2.CountNonZero(mask)` 获取符合条件的像素数
  - 对符合条件的像素使用掩码提取并求平均
2. Fallback 亮度/方差计算：
  - 使用 `Cv2.MeanStdDev` 替代手动循环计算

**注意事项**：

- 使用 `Cv2.ExtractChannel` 提取 Value 通道
- 掩码操作：`Cv2.Compare(sChannel, new Scalar(minSat), satMask, CmpType.GT)`

#### 1.4 FindBars 函数中的像素提取

**位置**：PuzzleDetector.cs 538-598 行
**当前问题**：颜色像素提取的双重循环（542-553 行）
**目标**：使用掩码提取和矩阵求和

**实施步骤**：

1. 使用掩码和矩阵乘法提取颜色像素：
  - 使用 `Cv2.Split(barHsv)` 分离通道
  - 使用掩码乘法提取需要通道的像素值
  - 使用 `Cv2.Sum` 计算总和
2. Filled 判断：
  - 使用 `Cv2.MeanStdDev` 替代手动循环计算标准差

#### 1.5 ParseComponentBlob 函数

**位置**：PuzzleDetector.cs 764-902 行
**当前问题**：颜色提取和形状分析中的像素遍历
**目标**：使用掩码操作

**实施步骤**：

1. 使用 `Cv2.CountNonZero` 和掩码操作统计像素
2. 使用矩阵操作进行轮廓分析

### 阶段 2：Linq 重构

#### 2.1 Nms 函数

**位置**：PuzzleDetector.cs 275-293 行
**目标**：使用 Linq 链式调用

**实施**：

- `boxes.OrderByDescending(b => b.Score).ToList()` - 已经是 Linq
- `sorted.Where(b => Iou(best, b) < iouThresh).ToList()` - 改为 Linq

#### 2.2 InferGrid 函数

**位置**：PuzzleDetector.cs 302-327 行
**目标**：使用 Linq 替代手动列表操作

**实施**：

- 使用 `Select`、`Distinct`、`OrderBy` 等方法
- `centers.Select(m => (m.X + m.W / 2, m.Y + m.H / 2)).ToList()`

#### 2.3 DetectComponents 函数

**位置**：PuzzleDetector.cs 633-659 行
**目标**：使用 Linq 排序

**实施**：

- `blobs.OrderBy(b => (b.Y, b.X)).ToList()` - 改为 Linq

#### 2.4 其他列表操作

- 在 `DetectGrid`、`FindBars` 等函数中使用 Linq 过滤和转换

### 阶段 3：验证

#### 3.1 性能基准测试

1. 在优化前使用相同的测试图片记录执行时间
2. 优化后使用相同图片记录执行时间
3. 对比提升幅度

#### 3.2 正确性验证

1. 使用相同的测试图片对比优化前后的识别结果
2. 验证输出的一致性（网格、格子类型、需求条、元件）

## 参考

- **Python 原型脚本**：`prototype/detect.py`（使用 NumPy 向量化操作）
- **REQ-015**：性能瓶颈分析（已完成）
- **OpenCvSharp 文档**：[https://shimat.github.io/opencvsharp_docs/](https://shimat.github.io/opencvsharp_docs/)
- **NumPy vs C# 循环对比**：
  - NumPy: `hue_sim = np.maximum(0.0, 1.0 - d / hue_width)`（向量化）
  - C# 当前: `for (int y = 0; y < hsv.Rows; y++) { for (int x = 0; x < hsv.Cols; x++) { ... } }`（逐像素）

## 相关文件

- `src/EndfieldPuzzleSolver.Recognition/PuzzleDetector.cs` - 已完成所有优化（SimilarityMapForColor、MatchTemplate、ClassifyCell、FindBars、ParseComponentBlob）
- `src/EndfieldPuzzleSolver.Recognition/ColorGrouper.cs` - 无需修改
- `prototype/detect.py` - Python 参考实现

## 变更详情

### 实施的优化

1. **SimilarityMapForColor 函数（605-674行）**
   - 使用 `Cv2.Split` 分离 HSV 通道
   - 使用 `ConvertTo` 将通道转换为 float 类型
   - 使用 `Cv2.Absdiff` 计算色相距离（`|h - ch|`）
   - 使用 `Cv2.Subtract` 和 `Cv2.Min` 计算最小距离（`min(d, 180-d)`）
   - 使用 `Cv2.Multiply` 操作符 `*` 计算色相相似度
   - 使用 `Cv2.Compare` 创建饱和度和亮度掩码
   - 使用 `Cv2.BitwiseAnd` 组合有效区域掩码
   - 完全替代了双重循环逐像素计算

2. **MatchTemplate 函数（254-285行）**
   - 使用 `Cv2.Threshold` 创建二值掩码
   - 使用 `FindNonZero` 一次性获取所有匹配点
   - 完全替代了双重循环遍历结果矩阵

3. **ClassifyCell 函数（357-447行）**
   - 锁定格检测：使用 `Cv2.Compare` 创建饱和度和亮度掩码
   - 使用 `Cv2.BitwiseAnd` 组合掩码
   - 使用 `Cv2.CountNonZero` 统计符合条件的像素数
   - 使用 `Cv2.Sum` 计算符合条件的像素的 HSV 总和
   - Fallback 亮度/方差计算：使用 `Cv2.MeanStdDev` 替代手动循环
   - 完全替代了多个双重循环

4. **FindBars 函数（544-690行）**
   - 使用 `Cv2.Split` 分离 barHsv 的通道
   - 使用掩码和 `Cv2.BitwiseAnd` 提取需要通道的像素值
   - 使用 `Cv2.Sum` 计算总和
   - Filled 判断：使用 `Cv2.MeanStdDev` 替代手动循环计算标准差
   - 完全替代了像素提取的双重循环

5. **ParseComponentBlob 函数（810-945行）**
   - 使用 `Cv2.Split` 分离 blobHsv 的通道
   - 使用 `Cv2.BitwiseAnd` 和掩码提取颜色像素
   - 使用 `Cv2.Sum` 计算颜色总和
   - 完全替代了双重循环遍历颜色像素

6. **Linq 重构**
   - Nms、InferGrid、DetectComponents 等函数已经在使用 Linq（OrderBy、Where、Select 等）
   - 无需额外修改

### 使用的 OpenCvSharp API

- `Cv2.Split()` - 分离图像通道
- `Cv2.Absdiff()` - 计算绝对差值
- `Cv2.Min()` / `Cv2.Max()` - 矩阵元素级最小/最大值
- `Cv2.Subtract()` - 矩阵减法
- `Cv2.Multiply()` - 矩阵乘法（包括标量乘法使用 `*` 操作符）
- `Cv2.Compare()` - 元素级比较生成掩码
- `Cv2.BitwiseAnd()` - 位与操作
- `Cv2.CountNonZero()` - 统计非零元素数
- `Cv2.Sum()` - 矩阵元素求和
- `Cv2.MeanStdDev()` - 计算均值和标准差
- `Cv2.Threshold()` - 阈值操作
- `FindNonZero()` - 获取非零元素位置

### 内存管理

- 所有临时 Mat 对象都正确使用 `Dispose()` 释放
- 使用 `using` 语句管理部分临时 Mat
- 确保 `Cv2.Split()` 返回的通道数组被正确释放

### 编译验证

- 编译成功，0 个错误，8 个警告（均为无关的 MVVMTK 和 AOT 警告）
- Recognition 项目构建成功

